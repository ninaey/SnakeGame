<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Pro ‚Äî Store Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f0f12;
            --surface: #1a1a20;
            --surface2: #24242c;
            --border: #2e2e38;
            --text: #e8e8ed;
            --textDim: #8888a0;
            --accent: #00d4aa;
            --accentHover: #00f0c0;
            --danger: #ff4757;
            --gold: #ffc107;
            --success: #2ed573;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }
        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 2rem;
            max-width: 480px;
        }
        .screen.active { display: flex; }

        /* Menu */
        .logo {
            font-size: 2.5rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, var(--accent), #00a080);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
        }
        .subtitle { color: var(--textDim); font-size: 0.95rem; margin-bottom: 2rem; }
        .btn {
            width: 100%;
            max-width: 280px;
            padding: 1rem 1.5rem;
            font-family: inherit;
            font-size: 1.1rem;
            font-weight: 600;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
        }
        .btn:active { transform: scale(0.98); }
        .btn-primary {
            background: linear-gradient(135deg, var(--accent), #00a080);
            color: var(--bg);
        }
        .btn-primary:hover { box-shadow: 0 6px 24px rgba(0, 212, 170, 0.35); }
        .btn-secondary {
            background: var(--surface2);
            color: var(--text);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover { background: var(--border); }
        .menu-btns { display: flex; flex-direction: column; gap: 0.75rem; align-items: center; }
        .high-score { color: var(--textDim); font-size: 0.9rem; margin-top: 1rem; }
        .high-score span { color: var(--accent); font-weight: 600; }

        /* Game */
        .game-hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 400px;
            padding: 0.5rem 0;
        }
        .hud-item { display: flex; align-items: center; gap: 0.5rem; font-weight: 600; }
        .hud-item .icon { font-size: 1.2rem; }
        .game-wrap {
            position: relative;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            border: 2px solid var(--border);
        }
        #game {
            display: block;
            width: 400px;
            height: 400px;
            background: #0a0a0c;
        }
        .game-actions {
            display: flex;
            gap: 0.75rem;
            width: 100%;
            max-width: 400px;
        }
        .game-actions .btn { flex: 1; }

        /* Pause overlay */
        .pause-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.75);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            border-radius: 14px;
        }
        .pause-overlay.visible { display: flex; }
        .pause-overlay h3 { font-size: 1.5rem; }

        /* Game Over */
        .game-over-title { font-size: 1.75rem; color: var(--danger); margin-bottom: 0.25rem; }
        .game-over-score { font-size: 1.25rem; color: var(--textDim); }
        .game-over-score strong { color: var(--accent); }
        .game-over-actions { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 280px; margin-top: 0.5rem; }

        /* Store */
        .store-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .store-title { font-size: 1.5rem; font-weight: 800; }
        .coins-badge {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            background: var(--surface2);
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            font-weight: 600;
            color: var(--gold);
        }
        .store-section { font-size: 0.85rem; color: var(--textDim); text-transform: uppercase; letter-spacing: 0.08em; margin: 1.25rem 0 0.5rem; width: 100%; max-width: 320px; }
        .store-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            width: 100%;
            max-width: 320px;
        }
        .store-card {
            background: var(--surface2);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .store-card.owned { border-color: var(--success); }
        .store-card.equipped { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent); }
        .store-card .preview {
            width: 64px;
            height: 64px;
            margin: 0 auto 0.75rem;
            border-radius: 10px;
        }
        .store-card .name { font-weight: 600; margin-bottom: 0.25rem; }
        .store-card .price { font-size: 0.9rem; color: var(--gold); margin-bottom: 0.75rem; }
        .store-card .price.free { color: var(--textDim); }
        .store-card button { width: 100%; padding: 0.5rem; font-size: 0.9rem; border-radius: 8px; font-family: inherit; font-weight: 600; cursor: pointer; border: none; background: var(--accent); color: var(--bg); }
        .store-card button:disabled { opacity: 0.6; cursor: not-allowed; }
        .store-card button.secondary { background: var(--surface); color: var(--text); border: 1px solid var(--border); }
        .store-back { margin-top: 1rem; }

        .cart-list { width: 100%; max-width: 320px; margin: 0.5rem 0; }
        .cart-item { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.9rem; }
        .cart-item-info { flex: 1; min-width: 80px; }
        .cart-item-price { color: var(--gold); font-weight: 600; }
        .cart-item-qty { display: flex; align-items: center; gap: 0.25rem; }
        .qty-btn { width: 28px; height: 28px; padding: 0; font-size: 1rem; line-height: 1; border-radius: 6px; border: 1px solid var(--border); background: var(--surface2); color: var(--text); cursor: pointer; font-family: inherit; }
        .qty-btn:hover { background: var(--border); }
        .qty-num { min-width: 1.5rem; text-align: center; }
        .cart-item-remove { padding: 0.25rem 0.5rem; font-size: 0.8rem; border-radius: 6px; border: 1px solid var(--danger); background: transparent; color: var(--danger); cursor: pointer; font-family: inherit; }
        .cart-item-remove:hover { background: var(--danger); color: var(--bg); }
        .cart-total { font-weight: 600; margin: 0.5rem 0; }
        #btnCheckout { margin-top: 0.5rem; }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: var(--surface2);
            border: 1px solid var(--border);
            padding: 0.75rem 1.25rem;
            border-radius: 10px;
            font-size: 0.95rem;
            opacity: 0;
            transition: transform 0.3s, opacity 0.3s;
            z-index: 100;
        }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }
        .toast.success { border-color: var(--success); }
        .toast.error { border-color: var(--danger); }
    </style>
</head>
<body>
    <div id="menu" class="screen active">
        <div class="logo">Snake Pro</div>
        <p class="subtitle">Store Edition ‚Äî Eat, grow, and customize.</p>
        <div class="menu-btns">
            <button class="btn btn-primary" id="btnPlay">Play</button>
            <button class="btn btn-secondary" id="btnStore">Store</button>
        </div>
        <p class="high-score">Best score: <span id="highScore">0</span></p>
    </div>

    <div id="gameScreen" class="screen">
        <div class="game-hud">
            <div class="hud-item"><span class="icon">‚≠ê</span> <span id="score">0</span></div>
            <div class="hud-item"><span class="icon">‚ù§Ô∏è</span> <span id="lives">3</span></div>
        </div>
        <div class="game-wrap">
            <canvas id="game" width="400" height="400"></canvas>
            <div id="pauseOverlay" class="pause-overlay">
                <h3>Paused</h3>
                <button class="btn btn-primary" id="btnResume">Resume</button>
            </div>
        </div>
        <div class="game-actions">
            <button class="btn btn-secondary" id="btnPause">Pause</button>
            <button class="btn btn-secondary" id="btnStoreInGame">Store</button>
        </div>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2 class="game-over-title">Game Over</h2>
        <p class="game-over-score">Score: <strong id="finalScore">0</strong></p>
        <p class="game-over-score" id="coinsEarnedLine">Coins earned: <strong id="coinsEarned">0</strong></p>
        <div class="game-over-actions">
            <button class="btn btn-primary" id="btnBuyLife">Buy extra life (50 coins)</button>
            <button class="btn btn-primary" id="btnRetry">Try again</button>
            <button class="btn btn-secondary" id="btnMenuFromGameOver">Menu</button>
            <button class="btn btn-secondary" id="btnStoreFromGameOver">Store</button>
        </div>
    </div>

    <div id="storeScreen" class="screen">
        <div class="store-header">
            <span class="store-title">Store</span>
            <div class="coins-badge">ü™ô <span id="storeCoins">0</span></div>
        </div>
        <p class="store-section">Lives</p>
        <div class="store-grid" id="storeLives"></div>
        <p class="store-section">Skins</p>
        <div class="store-grid" id="storeSkins"></div>
        <p class="store-section">Cart <span id="cartCount">(0)</span></p>
        <div id="cartList" class="cart-list"></div>
        <p class="cart-total">Total: <span id="cartTotal">0</span> ü™ô</p>
        <button class="btn btn-primary" id="btnCheckout" disabled>Create order</button>
        <button class="btn btn-secondary store-back" id="btnStoreBack">Back</button>
    </div>

    <div id="toast" class="toast"></div> 

    <script>
        const API = { base: '' };
        const box = 20;
        const gridSize = 400;
        const gridCells = gridSize / box;

        let state = {
            screen: 'menu',
            score: 0,
            lives: 3,
            extraLives: 0,
            speed: 200,
            snake: [],
            food: { x: 0, y: 0 },
            direction: null,
            nextDirection: null,
            gameLoop: null,
            paused: false,
            balance: 0,
            ownedSkins: ['default'],
            equippedSkin: 'default',
            highScore: parseInt(localStorage.getItem('snakeHighScore') || '0', 10)
        };

        const skins = {
            default: { name: 'Default', price: 0, head: '#2ed573', body: '#27ae60', eye: '#1a1a20' },
            skin_gold: { name: 'Gold', price: 100, head: '#ffd700', body: '#daa520', eye: '#1a1a20' },
            skin_rainbow: { name: 'Rainbow', price: 100, head: '#ff6b9d', body: '#c44dff', eye: '#1a1a20', gradient: true },
            skin_ice: { name: 'Ice', price: 100, head: '#87ceeb', body: '#b0e0e6', eye: '#1a1a20' },
            skin_fire: { name: 'Fire', price: 100, head: '#ff6b35', body: '#f7931e', eye: '#1a1a20' }
        };

        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const el = document.getElementById(id);
            if (el) el.classList.add('active');
            state.screen = id;
        }

        function toast(message, type = '') {
            const t = document.getElementById('toast');
            t.textContent = message;
            t.className = 'toast show ' + type;
            clearTimeout(toast._id);
            toast._id = setTimeout(() => { t.classList.remove('show'); }, 2500);
        }

        async function apiGet(path) {
            const r = await fetch(API.base + path);
            return r.json();
        }
        async function apiPost(path, body) {
            const r = await fetch(API.base + path, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            return r.json();
        }
        async function apiPatch(path, body) {
            const r = await fetch(API.base + path, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await r.json().catch(() => ({}));
            if (!r.ok) { const e = new Error(data.error || 'Request failed'); e.json = data; throw e; }
            return data;
        }
        async function apiDelete(path) {
            const r = await fetch(API.base + path, { method: 'DELETE' });
            const data = await r.json().catch(() => ({}));
            if (!r.ok) { const e = new Error(data.error || 'Request failed'); e.json = data; throw e; }
            return data;
        }

        async function loadPlayer() {
            try {
                const p = await apiGet('/api/player');
                state.balance = p.Balance ?? 0;
                state.ownedSkins = p.OwnedSkins || ['default'];
                state.equippedSkin = p.EquippedSkin || 'default';
                state.extraLives = Math.max(0, Number(p.ExtraLives) || 0);
            } catch (e) {
                state.balance = 0;
                state.ownedSkins = ['default'];
                state.equippedSkin = 'default';
                state.extraLives = 0;
            }
        }

        function getSkin(id) {
            return skins[id] || skins.default;
        }

        function drawSnake() {
            const skin = getSkin(state.equippedSkin);
            const isGradient = skin.gradient;
            state.snake.forEach((seg, i) => {
                const isHead = i === 0;
                let fill = isHead ? skin.head : skin.body;
                if (isGradient) {
                    const t = i / Math.max(state.snake.length, 1);
                    const r = Math.floor(255 * (1 - t) + 255 * t * 0.76);
                    const g = Math.floor(107 * (1 - t) + 212 * t * 0.5);
                    const b = Math.floor(115 * (1 - t) + 170 * t);
                    fill = `rgb(${r},${g},${b})`;
                }
                ctx.fillStyle = fill;
                roundRect(ctx, seg.x + 1, seg.y + 1, box - 2, box - 2, 6);
                if (isHead) {
                    ctx.fillStyle = skin.eye || '#1a1a20';
                    const [dx, dy] = directionOffset(state.direction);
                    const ex = seg.x + box / 2 + (dx * 6);
                    const ey = seg.y + box / 2 + (dy * 6);
                    ctx.beginPath();
                    ctx.arc(ex - 3, ey - 3, 3, 0, Math.PI * 2);
                    ctx.arc(ex + 3, ey - 3, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function directionOffset(d) {
            if (d === 'LEFT') return [-1, 0];
            if (d === 'RIGHT') return [1, 0];
            if (d === 'UP') return [0, -1];
            if (d === 'DOWN') return [0, 1];
            return [0, 0];
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();
        }

        function placeFood() {
            const used = new Set(state.snake.map(s => `${s.x},${s.y}`));
            let x, y;
            do {
                x = (Math.floor(Math.random() * (gridCells - 2)) + 1) * box;
                y = (Math.floor(Math.random() * (gridCells - 2)) + 1) * box;
            } while (used.has(`${x},${y}`));
            state.food = { x, y };
        }

        function drawFood() {
            ctx.fillStyle = '#ff4757';
            roundRect(ctx, state.food.x + 2, state.food.y + 2, box - 4, box - 4, 8);
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(state.food.x + box/2, state.food.y + 6, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        function tick() {
            if (state.paused) return;
            state.nextDirection = state.nextDirection || state.direction;
            if (!state.nextDirection) return;
            const d = state.nextDirection;
            const [dx, dy] = directionOffset(d);
            const head = state.snake[0];
            let nx = head.x + dx * box;
            let ny = head.y + dy * box;
            state.direction = d;
            state.nextDirection = null;

            if (nx < 0 || nx >= gridSize || ny < 0 || ny >= gridSize) {
                loseLife();
                return;
            }
            if (state.snake.some(s => s.x === nx && s.y === ny)) {
                loseLife();
                return;
            }

            state.snake.unshift({ x: nx, y: ny });
            if (nx === state.food.x && ny === state.food.y) {
                state.score++;
                document.getElementById('score').textContent = state.score;
                placeFood();
            } else {
                state.snake.pop();
            }
        }

        function loseLife() {
            clearInterval(state.gameLoop);
            state.gameLoop = null;
            if (state.extraLives > 0) {
                state.extraLives--;
                state.lives++;
            }
            state.lives--;
            document.getElementById('lives').textContent = state.lives;
            if (state.lives <= 0) {
                gameOver();
                return;
            }
            state.snake = [{ x: 10 * box, y: 10 * box }];
            state.direction = null;
            placeFood();
            state.gameLoop = setInterval(gameStep, state.speed);
        }

        function gameOver() {
            state.gameLoop = null;
            document.getElementById('finalScore').textContent = state.score;
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('snakeHighScore', String(state.highScore));
            }
            (async () => {
                try {
                    const res = await apiPost('/api/earn', { score: state.score });
                    const earned = res.earned ?? 0;
                    state.balance = res.balance ?? state.balance;
                    document.getElementById('coinsEarned').textContent = earned;
                    document.getElementById('coinsEarnedLine').style.display = 'block';
                } catch (e) {
                    document.getElementById('coinsEarnedLine').style.display = 'none';
                }
            })();
            document.getElementById('btnBuyLife').style.display = state.balance >= 50 ? 'block' : 'none';
            showScreen('gameOverScreen');
        }

        function gameStep() {
            tick();
            ctx.fillStyle = '#0a0a0c';
            ctx.fillRect(0, 0, gridSize, gridSize);
            drawFood();
            drawSnake();
        }

        function startGame(initialLives) {
            state.score = 0;
            if (initialLives !== undefined) {
                // Continuing after buying life on game over: use exactly that many lives
                state.lives = initialLives;
                state.extraLives = 0;
            } else {
                // Fresh game: base 3 lives + any extra lives bought in store
                state.lives = 3 + (state.extraLives || 0);
                state.extraLives = 0;
            }
            state.snake = [{ x: 10 * box, y: 10 * box }];
            state.direction = null;
            state.nextDirection = null;
            state.paused = false;
            document.getElementById('score').textContent = '0';
            document.getElementById('lives').textContent = state.lives;
            document.getElementById('pauseOverlay').classList.remove('visible');
            placeFood();
            if (state.gameLoop) clearInterval(state.gameLoop);
            state.gameLoop = setInterval(gameStep, state.speed);
            showScreen('gameScreen');
        }

        document.addEventListener('keydown', e => {
            if (state.screen !== 'gameScreen') return;
            const arrow = ['ArrowLeft', 'ArrowUp', 'ArrowRight', 'ArrowDown'].includes(e.key);
            if (e.key === ' ' || arrow) e.preventDefault();
            if (e.key === ' ') { togglePause(); return; }
            if (state.paused) return;
            const dir = state.nextDirection || state.direction;
            if (e.key === 'ArrowLeft' && dir !== 'RIGHT') state.nextDirection = 'LEFT';
            else if (e.key === 'ArrowUp' && dir !== 'DOWN') state.nextDirection = 'UP';
            else if (e.key === 'ArrowRight' && dir !== 'LEFT') state.nextDirection = 'RIGHT';
            else if (e.key === 'ArrowDown' && dir !== 'UP') state.nextDirection = 'DOWN';
        });

        function togglePause() {
            state.paused = !state.paused;
            document.getElementById('pauseOverlay').classList.toggle('visible', state.paused);
        }

        document.getElementById('btnPlay').onclick = () => { loadPlayer(); startGame(); };
        document.getElementById('btnStore').onclick = async () => { await loadPlayer(); if (typeof renderStore === 'function') renderStore(); showScreen('storeScreen'); };
        document.getElementById('btnStoreInGame').onclick = async () => {
            state.paused = true;
            document.getElementById('pauseOverlay').classList.add('visible');
            await loadPlayer();
            if (typeof renderStore === 'function') renderStore();
            showScreen('storeScreen');
        };
        document.getElementById('btnStoreBack').onclick = () => {
            if (state.screen === 'storeScreen') {
                if (state.gameLoop) { showScreen('gameScreen'); state.paused = false; document.getElementById('pauseOverlay').classList.remove('visible'); }
                else showScreen('menu');
            }
        };
        document.getElementById('btnResume').onclick = togglePause;
        document.getElementById('btnPause').onclick = togglePause;
        document.getElementById('btnRetry').onclick = () => { loadPlayer(); startGame(); };
        document.getElementById('btnMenuFromGameOver').onclick = () => showScreen('menu');
        document.getElementById('btnStoreFromGameOver').onclick = async () => { await loadPlayer(); if (typeof renderStore === 'function') renderStore(); showScreen('storeScreen'); };
        document.getElementById('btnBuyLife').onclick = async () => {
            if (state.balance < 50) { toast('Not enough coins', 'error'); return; }
            try {
                await apiPost('/api/user/cart/items', { itemId: 'extra_life' });
                const res = await apiPost('/api/user/orders', {});
                if (res.Status === 'Success') {
                    state.balance = res.Balance ?? state.balance;
                    state.extraLives = Math.max(0, Number(res.ExtraLives) || 0);
                    toast('Extra life purchased! Continue with 1 life.', 'success');
                    loadPlayer();
                    document.getElementById('btnBuyLife').style.display = 'none';
                    startGame(1);
                } else {
                    toast(res.Message || 'Purchase failed', 'error');
                }
            } catch (e) {
                toast('Network error', 'error');
            }
        };

        document.getElementById('highScore').textContent = state.highScore;
    </script>
    <script src="js/store.js?v=1"></script>
</body>
</html>